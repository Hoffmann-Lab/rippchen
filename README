### ABOUT
RIPPCHEN are tasty!
acquire a taste for RNA-Seq based gene expression analysis and peak calling from *IP-Seq experiments

RIPPCHEN comprises
1) a free implementation of ENCODE best practices for ChIP-Seq analysis
2) gene expression analysis comprising differential analysis, principal component analysis, coexpression clustering and go enrichment


### REFERENCES
(c) Konstantin Riege


### CONTACT
konstantin{.}riege{a}uni{-}jena{.}de
konstantin{a}bioinf{.}uni{-}leipzig{.}de
konstantin{.}riege{a}leibniz{-}fli{.}de

In case of troubles, don't hesitate to contact me


### REQUIREMENTS
- Internet access
- Linux
- ~10GB disk space for all dependencies and tools going to be installed


### INSTALLATION
1) create a shell variable RIPPCHEN assigned to an installation directory
export RIPPCHEN=/path/to/install/dir
3) store the RIPPCHEN variable permanently to ensure that RIPPCHEN can always find the required tools
echo "export RIPPCHEN=$RIPPCHEN" >> ~/.bashrc
4) download the latest RIPPCHEN release from https://github.com/koriege/rippchen
git clone --recursive https://github.com/koriege/rippchen.git
5) enter the RIPPCHEN directory 
cd rippchen
6) checkout latest stable release
git checkout $(git describe --tags)
7) install RIPPCHEN and all necessary tools (will take a while)
./setup.sh -i all -d $RIPPCHEN


### UPGRADE
1) follow the INSTALLATION steps 4 to 6
./setup.sh -i upgrade


### DOWNLOAD HG19/GRCh37 or HG38/GRCh38 or MM10/GRCm38 and corresponding files (annotation .gtf, ontology .go, description .info)
1) follow the INSTALLATION steps 4 to 6
./bashbone/scripts/dlgenome.sh -g [hg19|hg38|mm10] -o /path/to/genome/dir


### LOGS and verbosity
- a comprehensive log file 'run.log' file will be created in your output directory, unless defined otherwise
- using the verbose option '-v' will additionally print full log to terminals stdout


### FIRST RUN INFO
- genomes will be indexed for selected mappers
=> do not run multiple RIPPCHEN instances in parallel unless indexes are created
- in case indexes are already available 
=> copy $RIPPCHEN/latest/bashbone/lib/md5.sh to <genome.fa>.md5.sh and insert values returned by the command: md5sum <file>


### RUN
1) following the genome DOWNLOAD instruction will solve the following requirements:
- make sure to have your genome and all related file in the same directory
- all files need to share a common prefix (e.g. hg19.fa and hg19.fa.gtf)
- make sure your genome file ends with .fa and your annotation file ends with .fa.gtf
- make sure your annotation file ends with .fa.gtf and your ontology file ends with .fa.gtf.go
=> 3 tab-separated column file: gene_id GO_id GO_domain
- make sure your annotation file ends with .fa.gtf and your description file ends with '.fa.gtf.info'
=> 3 tab-separated column file: gene_id gene_name gene_description

2) calling for help?
$RIPPCHEN/latest/rippchen/rippchen.sh -h

3) synopsis
$RIPPCHEN/latest/rippchen/rippchen.sh -1 R1.fq -2 R2.fq -g genome.fa


### USECASES
1) fastq input preprocessing
$RIPPCHEN/latest/rippchen/rippchen.sh -v 2 -1 reads.fastq -o results -l results/log -tmp /tmp
# useful parameters
-no-qual : disables quality analysis
-no-trim : disables quality trimming
-no-cor  : disables majority based raw read error correction
-no-rrm  : disables rRNA filter
-skip [[qual|trim|cor|rrm],...]
-resume [qual|trim|cor|rrm]

2) read mapping
$RIPPCHEN/latest/rippchen/rippchen.sh -v 2 -1 reads.fastq -g genome.fa -o results -l results/log -tmp /tmp
# useful parameters
-no-qual : disables quality analysis
-no-trim : disables quality trimming
-no-cor  : disables majority based raw read error correction
-no-rrm  : disables rRNA filter
-no-sege : disables mapping by Segemehl
-no-star : disables mapping by STAR
-skip [[qual|trim|cor|rrm|sege|star],...]
-resume [sege|star]

3) mapping input postprocessing
$RIPPCHEN/latest/rippchen/rippchen -v 2 -m mapping.(sam|bam) -g genome.fa -o results -l results/log -tmp /tmp
# useful parameters
-no-uniq : mapping file contains only uniquely mapped reads
-no-sort : mapping file is already sorted
-no-rmd  : mapping file shall not be filtered for duplicates
-skip [[uniq|sort|rmd],...]
-resume [uniq|sort|rmd]

4) read quantification and TPM calculation
$RIPPCHEN/latest/rippchen/rippchen.sh -v 2 -m mapping.(sam|bam) -g genome.fa -gtf genome.gtf -o results -l results/log -tmp /tmp
# useful parameters
-no-uniq : mapping file contains only uniquely mapped reads
-no-sort : mapping file is already sorted
-no-rmd  : mapping file shall not be filtered for duplicates
-qt      : gene_id or transcript_id or ...
-ql      : exon or gene or CDS or ...
-skip [[uniq|sort|rmd],...]
-resume [uniq|sort|rmd]

5) differential expression analyses
$RIPPCHEN/latest/rippchen/rippchen.sh -v 2 -c COMPARISONS -m mapping.(sam|bam) -g genome.fa -gtf genome.gtf -o results -l results/log -tmp /tmp
# useful parameters
-no-uniq : mapping file contains only uniquely mapped reads
-no-sort : mapping file is already sorted
-cf      : decide for a subset of features to be clustered
-no-clust: disables feature co-expression clustering
-no-go   : disables GO enrichment calculation
-skip [[uniq|sort|quant|tpm|dea|clust|go],...]
-resume [uniq|sort|quant|tpm|dea|clust|go]

6) peak calling
$RIPPCHEN/latest/rippchen/rippchen.sh -v 2 -n1 ctr.fastq -t1 ip.N1.fastq -g genome.fa -o results -l results/log -tmp /tmp
# useful parameters
-nr1     : replicate N2 ctr file
-r1      : replicate N2 ip file
-f       : fragment size
-no-rmd  : mapping file shall not be filtered for duplicates
-no-macs : disables peak calling by macs
-no-gem  : disables peak calling by gem
-skip [[qual|trim|cor|rrm|uniq|sort|rmd],...]
-resume [qual|trim|cor|rrm|uniq|sort|rmd]

#####################################


..um meine Pipeline auf einem bcl Server zu nutzen musst du folgendes machen

export RIPPCHEN=/misc/paras/data/programs/rippchen
$RIPPCHEN/latest/rippchen/rippchen.sh -h

Es empfiehlt sich, da ja cutadapt, bzw pigz mit den glibc pthreads so seine probleme hat eine alternative lib zu nutzen
LD_PRELOAD=/lib64/noelision/libpthread.so.0 $RIPPCHEN/latest/rippchen/rippchen.sh [...]


hier eine List schon indexierter genome fuer star und segemehl zur Verwendung mit rippchen
/misc/paras/data/genomes/GRCh38.p12/GRCh38.p12.fa
/misc/paras/data/genomes/GRCh37.p13/GRCh37.p13.fa
/misc/paras/data/genomes/GRCm38.p6/GRCm38.p6.fa

falls du andere Genome nutzen willst, wird der Index vor dem mappen automatisch erzeugt. Bitte beachte, dass du dann aber keine parallelen rippchen Instanzen laufen lÃ¤sst.

zur Not kannst du die Indizes einfach so erstellen
echo -e '@1\nAAAAAAAAAAAAAAAAAAAA\n+\n44444444444444444444' > dummy.fastq
$RIPPCHEN/latest/rippchen/rippchen.sh -v 2 -t 1 -1 dummy.fastq -g <genome> -o <dummydir> -no-qual -no-clip -no-trim -no-cor -no-rrm -no-stats -no-star -no-sort -no-uniq -no-idx
$RIPPCHEN/latest/rippchen/rippchen.sh -v 2 -t 1 -1 dummy.fastq -g <genome> -o <dummydir> -no-qual -no-clip -no-trim -no-cor -no-rrm -no-stats -no-sege -no-sort -no-uniq -no-idx

wie du siehts, hat rippchen eigentlich nur opt-out parameter, wie z.b. das Deaktivieren der preprocessing und mapping statistiken (-no-stats), daher hier ein paar usecases

preprocessing ohne mapping (1) - default mit mapping mittels star UND segemehl, daher -no-sege -no-star
$RIPPCHEN/latest/rippchen/rippchen.sh -v 2 -t 56 -g <fasta> -gtf <gtf> -o <outdir> -l <logfile> -tmp </ssd/tmp/steve> -1 <fastq> [-2 <fastq>] -no-sege -no-star 

preprocessing ohne mapping (2) - default mit rcorrector (sequencing error correction) und sortmerna (rRNA depletion) aktiv, daher -no-cor UND -no-rrm
$RIPPCHEN/latest/rippchen/rippchen.sh -v 2 -t 56 -g <fasta> -gtf <gtf> -o <outdir> -l <logfile> -tmp </ssd/tmp/steve> -1 <fastq> [-2 <fastq>] -no-cor -no-rrm -no-sege -no-star 

preprocessing mit mapping
$RIPPCHEN/latest/rippchen/rippchen.sh -v 2 -t 56 -g <fasta> -gtf <gtf> -o <outdir> -l <logfile> -tmp </ssd/tmp/steve> -1 <fastq> [-2 <fastq>] <-no-cor|-no-rrm|-no-sege|-no-star>

preprocessing mit adapter sequenz(en) zum clippen via cutadapt
$RIPPCHEN/latest/rippchen/rippchen.sh [...] -a1 <ACGT,...> [-a2 <ACGT,...>]


bei mehreren inputs, kannst du rippchen so nutzen:
$RIPPCHEN/latest/rippchen/rippchen.sh [...] -1 <fastq,fastq,...> [-2 <fastq,fastq,...>]

falls du mehrere inputs via paralleler rippchen instanzen abarbeiten willst, solltest du die preprocessing und mapping statistik ausschalten und danach fuer alle inputs zusammen rechnen lassen

$RIPPCHEN/latest/rippchen/rippchen.sh [...] -1 <fastq> [-2 <fastq>] -no-stats
$RIPPCHEN/latest/rippchen/rippchen.sh [...] -1 <fastq> [-2 <fastq>] -no-stats
$RIPPCHEN/latest/rippchen/rippchen.sh [...] -1 <fastq,fastq> [-2 <fastq,fastq>] -redo stats

das ganze via sge


fyi: Bei der sge kannst du nodes definieren oder ausschliessen.

qsub [...] -l 'h=bcl102|bcl103'
qsub [...] -l 'h=!bcl102&!bcl103'

Ausserdem hab ich das parallele sge environment 'threads' angelegt, mit dem nodes nach definierter Auslastung belegt werden.

qsub [...] -pe threads $threads


mein Vorschlag fuer dich waere daher


shopt -s extglob
genome=/misc/paras/data/genomes/GRCh38.p12/GRCh38.p12.fa
gtf=/misc/paras/data/genomes/GRCh38.p12/GRCh38.p12.fa.gtf
outdir=/misc/paras/data/<path>/results
hosts="-l 'h=!bcl109'"
threads=56


fuer single-end daten

for i in /scratch/bcl103/data/<path>/*.fastq.gz; do
sh=$(basename $i .fastq.gz)
cat <<- EOF > $sh.sh
#!/usr/bin/env bash
export RIPPCHEN=/misc/paras/data/programs/rippchen
\$RIPPCHEN/latest/rippchen/rippchen.sh -v 2 -t $threads -1 $i -g $genome -gtf $gtf -o results -l results/$sh.log -tmp /ssd/tmp/rippchenrun -no-cor -no-rrm -no-stats -no-sege -no-quant
EOF
echo "rm -f $sh.+(log|err) && qsub -pe threads $threads $hosts -S /bin/bash -e $sh.err -o $sh.log -V -cwd $sh.sh"
done

bzw fuer paired-end daten

for i in /scratch/bcl103/data/<path>/*R1.fastq.gz; do
j=${i/R1/R2}
sh=$(basename $i .R1.fastq.gz)
cat <<- EOF > $sh.sh
#!/usr/bin/env bash
export RIPPCHEN=/misc/paras/data/programs/rippchen
\$RIPPCHEN/latest/rippchen/rippchen.sh -v 2 -t $threads -1 $i -2 $j -g $genome -gtf $gtf -o results -l results/$sh.log -tmp /ssd/tmp/rippchenrun -no-cor -no-rrm -no-stats -no-sege -no-quant
EOF
echo "rm -f $sh.+(log|err) && qsub -pe threads $threads $hosts -S /bin/bash -e $sh.err -o $sh.log -V -cwd $sh.sh"
done


wenn du clippen musst geht das auch in der sge und du brauchst immer die sequenz(en) - wie bei Cutadapt der -a/-A Parameter

du solltest dann aber unbedingt LD_PRELOAD voranstellen

LD_PRELOAD=/lib64/noelision/libpthread.so.0 $RIPPCHEN/latest/rippchen/rippchen.sh [...]

hier z.b. der Illumina universal adapter

-a1 AGATCGGAAGAG -a2 AGATCGGAAGAG

die lange Version, die im hg38 Genom uniq ist (die kurze ist 6x drin) kann ich allerdings nicht empfehlen - die funktioniert einfach nicht gut

-a1 AGATCGGAAGAGCACACGTCTGAACTCCAGTCA -a2 AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGT

Weitere adapter Sequenzen findest du hier:

https://github.com/timflutre/trimmomatic/tree/master/adapters