#! /usr/bin/env bash
# (c) Konstantin Riege

preprocessing::fastqc() {
	local funcname=${FUNCNAME[0]}
	_usage() {
		commander::printerr 3<<- EOF
			$funcname usage: 
			-S <hardskip> | true/false return
			-s <softskip> | true false only print commands
			-t <threads>  | number of
			-o <outdir>   | path to
			-1 <fastq1>   | array of
			-2 <fastq2>   | array of
		EOF
		return 0
	}

	local OPTIND arg mandatory skip threads outdir
	declare -n _ref_fq1 _ref_fq2
	while getopts 'S:s:t:o:1:2:' arg; do
		case $arg in
			S) $OPTARG && return 0;;
			s) $OPTARG && skip=true || skip=false;;
			t) ((mandatory++)); threads=$OPTARG;;
			o) ((mandatory++)); outdir="$OPTARG";;
			1) ((mandatory++)); _ref_fq1=$OPTARG;;
			2) ((mandatory++)); _ref_fq2=$OPTARG;;
			*) _usage; return 1;;
		esac
	done
	[[ $mandatory -lt 4 ]] && _usage && return 1

	commander::print "calculating qualities"

	declare -a cmd1
	local f
	for f in {"${_ref_fq1[@]}","${_ref_fq2[@]}"}; do
		commander::makecmd -a cmd1 -s '|' -c 3<<- CMD
			fastqc -outdir "$outdir" "$f"
		CMD
	done

	$skip && {
		commander::printcmd -a cmd1 
	} || {
		{	mkdir -p "$outdir" && \
			commander::runcmd -v -b -t $threads -a cmd1 
		} || { 
			commander::printerr "$funcname failed"
			return 1
		}
	}

	return 0
}

preprocessing::cutadapt() {
	local funcname=${FUNCNAME[0]}
	_usage() {
		commander::printerr 3<<- EOF
			$funcname usage: 
			-S <hardskip> | true/false return
			-s <softskip> | true false only print commands
			-a <adapter>  | array of
			-t <threads>  | number of
			-o <outdir>   | path to
			-1 <fastq1>   | array of
			-2 <fastq2>   | array of
		EOF
		return 0
	}

	local OPTIND arg mandatory skip threads outdir
	declare -n _ref_adapter _ref_fq1 _ref_fq2
	while getopts 'S:s:a:t:o:1:2:' arg; do
		case $arg in
			S) $OPTARG && return 0;;
			s) $OPTARG && skip=true || skip=false;;
			a) ((mandatory++)); _ref_adapter=$OPTARG;;
			t) ((mandatory++)); threads=$OPTARG;;
			o) ((mandatory++)); outdir="$OPTARG";;
			1) ((mandatory++)); _ref_fq1=$OPTARG;;
			2) ((mandatory++)); _ref_fq2=$OPTARG;;
			*) _usage; return 1;;
		esac
	done
	[[ $mandatory -lt 5 ]] && _usage && return 1

	commander::print "adapter clipping"

	local instances ithreads
	# parallelized cutadapt is faster on parallel data than max threads -> use max 10 per instance
	read -r instances ithreads <<< $(configure::instances -i ${#_ref_fq1[@]} -t 10 -T $threads)
	
	declare -a cmd1 cmd2
	local i o1 o2
	for i in "${!_ref_fq1[@]}"; do
		o1="$outdir"/$(basename "${_ref_fq1[$i]}")
		o2="$outdir"/$(basename "${_ref_fq2[$i]}")
		if [[ "${_ref_fq2[$i]}" ]]; then
			commander::makecmd -a cmd1 -s '|' -c 3<<- CMD
				cutadapt
				${_ref_adapter[@]/#/-b }
				${_ref_adapter[@]/#/-B }
				-j $ithreads
				-m 18
				-o "$o1"
				-p "$o2"
				"${_ref_fq1[$i]}" "${_ref_fq2[$i]}"
			CMD
			helper::makezipcmd -a cmd2 -t $threads -c "${_ref_fq1[$i]}" -c "${_ref_fq2[$i]}" -z o1 -z o2
			_ref_fq1[$i]="$o1"
			_ref_fq2[$i]="$o2"
		else
			commander::makecmd -a cmd1 -s '|' -c 3<<- CMD
				cutadapt
				${_ref_adapter[@]/#/-b }
				-j $threads
				-m 18
				-o "$o1"
				"${_ref_fq1[$i]}"
			CMD
			helper::makezipcmd -a cmd2 -t $threads -c "${_ref_fq1[$i]}" -z o1
			_ref_fq1[$i]="$o1"
		fi			
	done

	$skip && {
		commander::printcmd -a cmd1
		commander::printcmd -a cmd2
	} || {
		{	mkdir -p "$outdir" && \
			commander::runcmd -v -b -t $instances -a cmd1 && \
			commander::runcmd -v -b -t $instances -a cmd2
		} || { 
			commander::printerr "$funcname failed"
			return 1
		}
	}

	return 0
}

preprocessing::trimmomatic() {
	local funcname=${FUNCNAME[0]}
	_usage() {
		commander::printerr 3<<- EOF
			$funcname usage: 
			-S <hardskip> | true/false return
			-s <softskip> | true false only print commands
			-t <threads>  | number of
			-m <memory>   | amount of
			-o <outdir>   | path to
			-p <tmpdir>   | path to
			-1 <fastq1>   | array of
			-2 <fastq2>   | array of
		EOF
		return 0
	}

	local OPTIND arg mandatory skip threads memory outdir tmpdir
	declare -n _ref_fq1 _ref_fq2
	while getopts 'S:s:t:m:o:p:1:2:' arg; do
		case $arg in
			S) $OPTARG && return 0;;
			s) $OPTARG && skip=true || skip=false;;
			t) ((mandatory++)); threads=$OPTARG;;
			o) ((mandatory++)); outdir="$OPTARG";;
			p) ((mandatory++)); tmpdir="$OPTARG";;
			m) ((mandatory++)); memory=$OPTARG;;
			1) ((mandatory++)); _ref_fq1=$OPTARG;;
			2) ((mandatory++)); _ref_fq2=$OPTARG;;
			*) _usage; return 1;;
		esac
	done
	[[ $mandatory -lt 6 ]] && _usage && return 1

	commander::print "trimming"

	#offset 64: ASCII 64 to 106 (solexa: 59 to 106)
	#offset 33: ASCII 33 to 75
	#64 to 33: ord(char)-33+2
	#theoretical max range is 126 for all encodings, thus more reliable detection would be just min based
	#https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2847217/
	#https://www.drive5.com/usearch/manual/quality_score.html
	#od -v -A n -t u1
	declare -a cmd1
	local f catcmd
	for f in "${_ref_fq1[@]}"; do
		helper::makecatcmd -c catcmd -f $f
		commander::makecmd -a cmd1 -s ' ' -c 3<<- CMD 4<<- 'CMD' 5<<- CMD
			$catcmd $f | head -4000
		CMD
			| perl -M'List::Util qw(min max)' -slne '
				BEGIN{
					$min=106
				}
				if($.%4==0){
					@x=unpack"C*";
					$min=min($min,@x);
					$max=max($max,@x);
				}
				END{
					if($min>=33 && $max<=75){
						print "phred33 $f";
					}elsif($min>=64 && $max>75 && $max<=106){
						print "phred64 $f";
					}elsif($min>=59 && $min<64 && $max>75 && $max<=106){
						print "solexa64 $f";
					}else{
						print "unknown $f";
					}
				}
			'
		CMD
			-- -f="$f"
		CMD
	done

	declare -A _phred_
	local l
	mapfile -t <<< $(commander::runcmd -t $threads -a cmd1)
	for l in "${MAPFILE[@]}"; do
		mapfile -d ' ' -t <<< $l
		_phred_[${MAPFILE[@]:1}]=${MAPFILE[0]}
	done

	local instances ithreads jmem jgct jcgct
	read -r instances ithreads jmem jgct jcgct <<< $(configure::jvm -i ${#_ref_fq1[@]} -t 6 -T $threads -m $memory)

	declare -a cmd2 cmd3
	local i o1 o2
	for i in "${!_ref_fq1[@]}"; do
		o1="$outdir"/$(basename "${_ref_fq1[$i]}")
		o2="$outdir"/$(basename "${_ref_fq2[$i]}")
		os1="$outdir"/singletons.$(basename "${_ref_fq1[$i]}")
		os2="$outdir"/singletons.$(basename "${_ref_fq2[$i]}")
		if [[ ${_ref_fq2[$i]} ]]; then
			commander::makecmd -a cmd2 -s '|' -c 3<<- CMD
				trimmomatic
				-Xmx${jmem}m
				-XX:ParallelGCThreads=$jgct
				-XX:ConcGCThreads=$jcgct
				-Djava.io.tmpdir="$tmpdir"
				PE
				-threads $ithreads
				-${_phred_["${_ref_fq1[$i]}"]}
				"${_ref_fq1[$i]}" "${_ref_fq2[$i]}"
				"$o1" "$os1"
				"$o2" "$os2"
				SLIDINGWINDOW:5:22
				MINLEN:18
				TOPHRED33
			CMD
			helper::makezipcmd -a cmd3 -t $threads -c "${_ref_fq1[$i]}" -c "${_ref_fq2[$i]}" -z o1 -z o2
			helper::makezipcmd -a cmd3 -t $threads -c "${_ref_fq1[$i]}" -c "${_ref_fq2[$i]}" -z os1 -z os2
			_ref_fq1[$i]="$o1"
			_ref_fq2[$i]="$o2"
		else
			commander::makecmd -a cmd2 -s '|' -c 3<<- CMD
				trimmomatic
				-Xmx${jmem}m
				-XX:ParallelGCThreads=$jgct
				-XX:ConcGCThreads=$jcgct
				-Djava.io.tmpdir="$tmpdir"
				SE
				-threads $ithreads
				-${_phred_["${_ref_fq1[$i]}"]}
				"${_ref_fq1[$i]}"
				"$o1"
				SLIDINGWINDOW:5:22
				MINLEN:18
				TOPHRED33
			CMD
			helper::makezipcmd -a cmd3 -t $threads -c "${_ref_fq1[$i]}" -z o1
			_ref_fq1[$i]="$o1"
		fi
	done

	$skip && {
		commander::printcmd -a cmd2 
		commander::printcmd -a cmd3
	} || {
		{	mkdir -p "$outdir" && \
			commander::runcmd -v -b -t $instances -a cmd2 && \
			commander::runcmd -v -b -t 1 -a cmd3
		} || {
			commander::printerr "$funcname failed"
			return 1
		}
	}

	return 0
}

preprocessing::rcorrector() {
	local funcname=${FUNCNAME[0]}
	_usage() {
		commander::printerr 3<<- EOF
			$funcname usage: 
			-S <hardskip> | true/false return
			-s <softskip> | true false only print commands
			-t <threads>  | number of
			-o <outdir>   | path to
			-p <tmpdir>   | path to
			-1 <fastq1>   | array of
			-2 <fastq2>   | array of
		EOF
		return 0
	}

	local OPTIND arg mandatory skip threads outdir tmpdir
	declare -n _ref_fq1 _ref_fq2
	while getopts 'S:s:t:o:p:1:2:' arg; do
		case $arg in
			S) $OPTARG && return 0;;
			s) $OPTARG && skip=true || skip=false;;
			t) ((mandatory++)); threads=$OPTARG;;
			o) ((mandatory++)); outdir="$OPTARG";;
			p) ((mandatory++)); tmpdir="$OPTARG";;
			1) ((mandatory++)); _ref_fq1=$OPTARG;;
			2) ((mandatory++)); _ref_fq2=$OPTARG;;
			*) _usage; return 1;;
		esac
	done
	[[ $mandatory -lt 5 ]] && _usage && return 1

	commander::print "correcting read errors"

	declare -a cmd1 cmd2
	local i o1 b1 e1 o2 b2 e2
	for i in "${!_ref_fq1[@]}"; do
		o1="$outdir"/$(basename "${_ref_fq1[$i]}")
		o2="$outdir"/$(basename "${_ref_fq2[$i]}")
		helper::basename -f "${_ref_fq1[$i]}" -o b1 -e e1
		helper::basename -f "${_ref_fq2[$i]}" -o b2 -e e2
		b1="$outdir"/"$b1"
		b2="$outdir"/"$b2"
		if [[ ${_ref_fq2[$i]} ]]; then
			commander::makecmd -a cmd1 -s '&&' -c 3<<- CMD 4<<- CMD 5<<- CMD 6<<- CMD
				cd "$tmpdir"
			CMD
				run_rcorrector.pl
				-1 "${_ref_fq1[$i]}"
				-2 "${_ref_fq2[$i]}"
				-od "$outdir"
				-t $threads
			CMD
				mv "$b1".cor.fq* "$o1"
			CMD
				mv "$b2".cor.fq* "$o2"
			CMD
			commander::printcmd -a cmd1
			helper::makezipcmd -a cmd2 -t $threads -c "${_ref_fq1[$i]}" -c "${_ref_fq2[$i]}" -z o1 -z o2
			_ref_fq1[$i]="$o1"
			_ref_fq2[$i]="$o2"
		else
			commander::makecmd -a cmd1 -s '&&' -c 3<<- CMD 4<<- CMD 5<<- CMD
				cd "$tmpdir"
			CMD
				run_rcorrector.pl 
				-s "${_ref_fq1[$i]}" 
				-od "$outdir" 
				-t $threads 
			CMD
				mv "$b1".cor.fq* "$o1"
			CMD
			helper::makezipcmd -a cmd2 -t $threads -c "${_ref_fq1[$i]}" -z o1
			_ref_fq1[$i]="$o1"
		fi
	done

	$skip && {
		commander::printcmd -a cmd1
		commander::printcmd -a cmd2
	} || {
		{	mkdir -p "$outdir" && \
			commander::runcmd -v -b -t 1 -a cmd1 && \
			commander::runcmd -v -b -t 1 -a cmd2
		} || { 
			commander::printerr "$funcname failed"
			return 1
		}
	}

	return 0
}

preprocessing::sortmerna() {
	local funcname=${FUNCNAME[0]}
	_usage() {
		commander::printerr 3<<- EOF
			$funcname usage: 
			-S <hardskip> | true/false return
			-s <softskip> | true false only print commands
			-t <threads>  | number of
			-m <memory>   | amount of
			-o <outdir>   | path to
			-p <tmpdir>   | path to
			-1 <fastq1>   | array of
			-2 <fastq2>   | array of
		EOF
		return 0
	}

	local OPTIND arg mandatory skip threads memory outdir tmpdir
	declare -n _ref_fq1 _ref_fq2
	while getopts 'S:s:t:m:o:p:1:2:' arg; do
		case $arg in
			S) $OPTARG && return 0;;
			s) $OPTARG && skip=true || skip=false;;
			t) ((mandatory++)); threads=$OPTARG;;
			m) ((mandatory++)); memory=$OPTARG;;
			o) ((mandatory++)); outdir="$OPTARG";;
			p) ((mandatory++)); tmpdir="$OPTARG";;
			1) ((mandatory++)); _ref_fq1=$OPTARG;;
			2) ((mandatory++)); _ref_fq2=$OPTARG;;
			*) _usage; return 1;;
		esac
	done
	[[ $mandatory -lt 6 ]] && _usage && return 1

	commander::print "filtering rRNA fragments"

	declare -a cmd1 cmd2 cmd3
	local i catcmd tmp o1 o2 or1 or2 b1 b2 e1 e2 instances=$threads
	for i in "${!_ref_fq1[@]}"; do
		helper::basename -f "${_ref_fq1[$i]}" -o b1 -e e1
		helper::basename -f "${_ref_fq2[$i]}" -o b2 -e e2 &> /dev/null
		e1=${e1%%.*} # trim potential compressing extension
		e2=${e1%%.*}

		tmp="$tmpdir"/merged."$b1".$e1
		tmpo="$tmpdir"/"$b1"
		tmpr="$tmpdir"/rRNA."$b1"
		
		o1="$outdir"/"$b1".$e1.gz
		o2="$outdir"/"$b2".$e2.gz
		or1="$outdir"/rRNA."$b1".$e1.gz
		or2="$outdir"/rRNA."$b2".$e2.gz

		# sortmerna v2.1 input must not be compressed (v.3.* creates empty files)
		# outfile gets extension from input file
		# in.fq.bz2 > in.fq + rRNA.out|out -> rRNA.out.fq|out.fq -> rRNA.out.fq.gz|out.fq.gz
		if [[ ${_ref_fq2[$i]} ]]; then
			instances=1
			commander::makecmd -a cmd1 -s '|' -c 3<<- CMD
				mergefq
				-t $threads
				-m ${memory}M
				-d "$tmpdir"
				-i "${_ref_fq1[$i]}"
				-j "${_ref_fq2[$i]}"
				-o "$tmp"
			CMD
			commander::makecmd -a cmd2 -s '|' -c 3<<- CMD
				sortmerna
				--ref "$sortmernaref"
				--reads "$tmp"
				--fastx
				--paired_out
				--aligned "$tmpr"
				--other "$tmpo"
				-a $threads
			CMD
			commander::makecmd -a cmd3 -s '|' -c 3<<- CMD
				mergefq
				-t $threads
				-u 1
				-i "$tmpo".$e1
				-z
				-o $o1
			CMD
			commander::makecmd -a cmd3 -s '|' -c 3<<- CMD
				mergefq
				-t $threads
				-u 2
				-i "$tmpo".$e1
				-z
				-o "$o2"
			CMD
			commander::makecmd -a cmd3 -s '|' -c 3<<- CMD
				mergefq
				-t $threads
				-u 1
				-i "$tmpr".$e1
				-z
				-o "$or1"
			CMD
			commander::makecmd -a cmd3 -s '|' -c 3<<- CMD
				mergefq
				-t $threads
				-u 2
				-i "$tmpr".$e1
				-z
				-o "$or2"
			CMD
			_ref_fq1[$i]="$o1"
			_ref_fq2[$i]="$o2"
		else
			helper::makecatcmd -c catcmd -f "${_ref_fq1[$i]}"
			[[ $catcmd == "cat" ]] && {
				tmp="${_ref_fq1[$i]}"
			} || {
				commander::makecmd -a cmd1 -s '|' -c 3<<- CMD
					$catcmd "${_ref_fq1[$i]}" > $tmp
				CMD
			}

			commander::makecmd -a cmd2 -s '|' -c 3<<- CMD
				sortmerna
				--ref "$sortmernaref"
				--reads "$tmp"
				--fastx
				--aligned "$tmpr"
				--other "$tmpo"
				-a $threads
			CMD
			commander::makecmd -a cmd3 -s '|' -c 3<<- CMD
				pigz 
				-p $threads
				-k
				-c
				"$tmpr".$e1 > "$or1"
			CMD
			commander::makecmd -a cmd3 -s '|' -c 3<<- CMD
				pigz 
				-p $threads
				-k
				-c
				"$tmpo".$e1 > "$o1"
			CMD
			_ref_fq1[$i]="$o1"
		fi
	done

	$skip && {
		commander::printcmd -a cmd1
		commander::printcmd -a cmd2
		commander::printcmd -a cmd3
	} || {
		{	mkdir -p "$outdir" && \
			commander::runcmd -v -b -t $instances -a cmd1 && \
			commander::runcmd -v -b -t 1 -a cmd2 && \
			commander::runcmd -v -b -t 1 -a cmd3
		} || { 
			commander::printerr "$funcname failed"
			return 1
		}
	}

	return 0
}
