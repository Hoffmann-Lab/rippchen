#!/usr/bin/env bash
# (c) Konstantin Riege

commander::print(){
	[[ $* ]] && echo ":INFO: $*" >&2
	local fd tmp
	for fd in {3..255}; do
		read -u $fd -r tmp 2> /dev/null || break
		echo $tmp
		while read -u $fd -r tmp 2> /dev/null; do
			echo $tmp
		done
	done

	return 0
}

commander::printerr(){
	echo -ne "\e[0;31m"
	[[ $* ]] && echo ":ERROR: $*" >&2
	local fd tmp
	for fd in {3..255}; do
		read -u $fd -r tmp 2> /dev/null || break
		echo $tmp >&2
		while read -u $fd -r tmp 2> /dev/null; do
			echo $tmp >&2
		done
	done
	echo -ne "\e[m"

	return 0
}

commander::makecmd(){
	local funcname=${FUNCNAME[0]}
	_usage(){
		commander::printerr 3<<- EOF
			$funcname usage:
			-a <cmds>      | array of 
			-s <seperator> | single character
			-c <cmd|fd3..> | ALWAYS LAST OPTION
			                 command line string(s) and or
			                 file descriptor(s) starting from 3
			example: 
			$funcname -a cmds -s '|' -c perl -l - 3<<- CMD 4<<- 'CMD'
			    <<< '
			        print "$x";
			    '
			CMD
			    awk '{print $0}'
			CMD
		EOF
		return 0
	}

	local OPTIND arg mandatory sep='|' fd tmp
	declare -n _ref_makecmd # be very careful with circular name reference
	declare -a _cmd_makecmd # be very careful with references name space
	while getopts ':a:s:c' arg; do
		case $arg in
			a)	mendatory=1; _ref_makecmd=$OPTARG;;
			s)	sep=$(echo -e "${OPTARG:- }");; # '\t' possible; old: _sep=${OPTARG:-' '}
			c)	[[ ! $mendatory ]] && { _usage; return 1; }
				shift $((OPTIND-1)) # remove '-a <cmd> -s <char> -c' from $*
				for fd in {3..255}; do
					mapfile -u $fd -t 2> /dev/null || break
					_cmd_makecmd+=("${MAPFILE[*]}") # * instaead of @ to concatenate
					# exec $i>&- to close fd not necessary since heredoc is read only and handles closure
				done
				tmp="${_cmd_makecmd[*]/#/$sep }" # concatenate CMD* with |
				_ref_makecmd+=("$* ${tmp/#$sep /}\0") # append null for xargs
				return 0;;
			*)	_usage
				return 1;;
		esac
	done

	{ _usage; return 1; }
}

commander::printcmd(){
	local funcname=${FUNCNAME[0]}
	_usage(){
		commander::printerr 3<<- EOF
			$funcname usage:
			-a <cmds> | array of
		EOF
		return 0
	}

	local OPTIND arg
	declare -n _ref_printcmd # be very careful with circular name reference
	while getopts 'a:' arg; do
		case $arg in
			a)	_ref_printcmd=$OPTARG
				echo -n "${_ref_printcmd[@]}" | sed 's/\\0\s*/\n/g' | sed 's/^\s*/:CMD: /'
				return 0;;
			*)	_usage
				return 1;;
		esac
	done

	{ _usage; return 1; }
}

commander::runcmd(){
	local funcname=${FUNCNAME[0]}
	_usage(){
		commander::printerr 3<<- EOF
			$funcname usage:
			-v           | verbose on
			-b           | benchmark on
			-t <threads> | number of
			-a <cmds>    | ALWAYS LAST OPTION
			               array of
			example:
			$funcname -v -b -t 1 -a cmd
		EOF
		return 0
	}

	local OPTIND arg threads=1 verbose=false benchmark=false
	declare -n _ref_runcmd # be very careful with circular name reference
	while getopts 'vbt:a:' arg; do
		case $arg in
			t)	threads=$OPTARG;;
			v)	verbose=true;;
			b)	benchmark=true;;
			a)	_ref_runcmd=$OPTARG
				[[ $_ref_runcmd ]] || return 0
				$verbose && {
					echo ":INFO: running commands of array ${!_ref_runcmd}"
					commander::printcmd -a _ref_runcmd
				}
				$benchmark && {
					echo -e "${_ref_runcmd[@]}" | time -f ":BENCHMARK: runtime %E [hours:]minutes:seconds\n:BENCHMARK: memory %M Kbytes" xargs -0 -P $threads -I {} bash -c {}
				} || {
					echo -e "${_ref_runcmd[@]}" | xargs -0 -P $threads -I {} bash -c {}
				}
				return $((${PIPESTATUS[@]/%/+}0));;
			*)	_usage
				return 1;;
		esac
	done

	return 1
}

commander::_test(){
	local x=${1:-'hello world'} threads=${2:-1} i=3 s

	while read -u $((i++)) -r s 2> /dev/null; do
		echo $s
	done 3<<< 'foo' 4<<- EOF 5< <(echo baz)
		bar
	EOF

	declare -a cmd
	commander::makecmd -a cmd -c perl -sl - -x="'$x'" \<\<\< \''print "$x"'\' \| awk \''{print $0}'\'

	commander::makecmd -a cmd -c perl -sl - -x="'$x'" 3<<- 'CMD'
		<<< '
			print "$x";
		' | awk '{print $0}'
	CMD

	commander::makecmd -a cmd -c perl -l - 3<<- CMD
		<<< '
			print "$x";
		' | awk '{print \$0}'
	CMD

	commander::makecmd -a cmd -c 3<<- CMD 4<<- 'CMD'
		perl -l - <<< '
			print "$x";
		'
	CMD
		awk '{print $0}'
	CMD

	commander::makecmd -a cmd -s ' ' -c perl -s - -x="'$x'" 3<<- 'CMD' 4<<- CMD
		<<< '
			print "$x";
	CMD
			print " $x\n";
		'
	CMD

	commander::runcmd -v -b -t $threads -a cmd || commander::printerr "failed"

	commander::printerr ${FUNCNAME[0]} EXPECTED OUTPUT
	commander::printerr 3<<-OUT
		foo
		bar
		baz
		:INFO: running commands of array cmd
		:CMD: perl -sl - -x='hello world' <<< 'print "$x"' | awk '{print $0}' 
		:CMD: perl -sl - -x='hello world' <<< ' print "$x"; ' | awk '{print $0}'
		:CMD: perl -l - <<< ' print "hello world"; ' | awk '{print $0}'
		:CMD: perl -l - <<< ' print "hello world"; ' |awk '{print $0}'
		:CMD: perl -s - -x='hello world' <<< ' print "$x";  print " hello world\n"; '
		hello world
		hello world
		hello world
		hello world
		hello world hello world
		:BENCHMARK: runtime 0:00.03 [hours:]minutes:seconds
		:BENCHMARK: memory 4328 Kbytes
	OUT
}


: <<-INFO
### idea simplified
makecmd(){
	declare -n arref=$1
	shift
	arref+=("$*\0")
}
runcmd(){
	threads=$1
	declare -n arref=$2
	echo -ne "${arref[@]}" | xargs -0 -P $threads -I {} bash -c {}
}
cmd=()
for i in {1..3}; do
	makecmd cmd echo $i \| perl -lane \''
		print "\"$_\"";
	'\'
	makecmd cmd << EOF
		echo $i | perl -lane '
		print "\$_";
	'
	EOF
done
runcmd 1 cmd

### file descriptors
exec 3> tmp
echo 'echo baz' >&3
exec 3>&-
exec 3< tmp
cat <&3 tmp

# here document implicitly calls 'exec 0< /dev/fd/0; echo .. >&0; exec 0<&- /dev/fd/0'
cat <<-CMD
	echo echo0
CMD
# equal to (0 = STDIN)
cat 0<<-CMD /dev/fd/0
	echo echo0
CMD
# using different descriptors !=1 (1 = STDOUT, 2 = STDERR)
cat 2<<-CMD /dev/fd/2
	echo echo2
CMD
cat 3<<-CMD /dev/fd/3
	echo echo3
CMD

# allow or deny all kinds of parameter expansion
cat 0<<-CMD 2<<-'CMD' 3<<-'CMD' /dev/fd/0 /dev/fd/2 /dev/fd/3
	echo $x |
CMD
	perl -lane '
		print "$_"
	' |
CMD
	awk '{
		print $0
	}'
CMD

INFO
